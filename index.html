<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <title>WebCam Computer Vision</title>
    </head>
<body>
    <script src="opencv.js" type="text/javascript"></script>
    <script type="text/javascript">
        
        const video = document.createElement('video')
        video.setAttribute('id','webcamVideo')
        video.setAttribute('muted','true')

        let canvasNum = 5
        let canvasArr = []
        
        function setupCanvases(width, height){
            for(let i = 0; i < canvasNum; i++){
                let canvas = document.createElement('canvas')
                canvas.setAttribute('id', 'canvas'+i)
                canvas.setAttribute('width', width)
                canvas.setAttribute('height', height)
                document.body.appendChild(canvas)
                canvasArr.push(canvas)
            }
        }

        sliders = []
        function addSlider(desc, min, max, val){
            if(min > max || val > max || val < min){
                console.log('Tried to create slider with bad min,max,value. Returning')
                return
            }
            let div = document.createElement('div')
            let label = document.createElement('label')
            let slider = document.createElement('input')
            slider.setAttribute('name',desc)
            slider.setAttribute('type','range')
            slider.setAttribute('min',min)
            slider.setAttribute('max',max)
            slider.setAttribute('value',val)

            label.textContent = desc+' : '+val

            document.body.appendChild(div)
            div.appendChild(slider)
            div.appendChild(label)
            
            slider.addEventListener('input', (event) =>{
                let labels = event.target.parentElement.getElementsByTagName('label')
                if(labels.length == 0){
                    console.log('Slider input updated, but no label? Returning')
                    return
                }
                labels[0].textContent = event.target.name+' : '+event.target.value
            })
            

            sliders.push(slider)
        }

        navigator.getUserMedia = (
            navigator.getUserMedia ||
            navigator.webkitGetUserMedia ||
            navigator.mozGetUserMedia ||
            navigator.msGetUserMedia
        );
        
        //request webcam access
        navigator.getUserMedia (
        {
            video: true,
            audio: false
        },
        // success callback
        function(stream) {
            console.log('Successfully got access to camera')
            let {width, height} = stream.getTracks()[0].getSettings()
            console.log("Got (w.h) from stream settings ("+width+", "+height+")")
            video.srcObject = stream
            video.play()

            setupCanvases(width,height)

            //setup sliders for adjusting opencv params
            //bilat filter
            addSlider('PixelSize', 1, 64, 7)
            addSlider('SigmaColor', 0, 255, 50)
            addSlider('PixelSize', 0, 255, 50)
            //Canny
            addSlider('Thresh1', 0, 255, 20)
            addSlider('Thresh2', 0, 255, 60)
            //HoughLines
            addSlider('Rho', 1, 255, 1)
            addSlider('Theta', 1, 360, 180)
            addSlider('Thresh', 0, 64, 2)
            addSlider('Srn', 0, 255, 0)
            addSlider('Stn', 0, 255, 0)
            
        },
        // fail callback
        function(err) {
            console.log('Failed to get webcam access: '+err)
        }
        );

        //main processing loop.
        function processFrame(timestamp){
            let ctx = canvasArr[0].getContext('2d')
            ctx.drawImage(video, 0, 0, canvasArr[0].width, canvasArr[0].height)

            let mat = cv.imread(canvasArr[0].id)
            let temp_mat = cv.Mat.zeros(mat.rows, mat.cols, cv.CV_8UC3)
            let temp_mat2 = cv.Mat.zeros(mat.rows, mat.cols, cv.CV_8UC3)
            let lines = new cv.Mat()
            let color = new cv.Scalar(200, 150, 150)
            
            //Gray scale
            cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY)
            cv.imshow(canvasArr[1].id, mat)

            //bilateral filter
            cv.bilateralFilter(mat, temp_mat, parseInt(sliders[0].value), parseInt(sliders[1].value), parseInt(sliders[2].value), cv.BORDER_DEFAULT) // cv.bilateralFilter( src, dst, d, sigmaColor, sigmaSpace[, dst[, borderType]] )
            cv.imshow(canvasArr[2].id, temp_mat)

            //Canny
            cv.Canny(temp_mat, mat, parseInt(sliders[3].value), parseInt(sliders[4].value), 3)
            cv.imshow(canvasArr[3].id, mat)

            //Hough Lines
            cv.HoughLinesP(mat, lines, parseInt(sliders[5].value), Math.PI / parseInt(sliders[6].value), parseInt(sliders[7].value), parseInt(sliders[8].value), parseInt(sliders[9].value));

            // draw lines 
            for (let i = 0; i < lines.rows; ++i) {
                let startPoint = new cv.Point(lines.data32S[i * 4], lines.data32S[i * 4 + 1])
                let endPoint = new cv.Point(lines.data32S[i * 4 + 2], lines.data32S[i * 4 + 3])
                cv.line(temp_mat2, startPoint, endPoint, color)
            }
            cv.imshow(canvasArr[4].id, temp_mat2)

            mat.delete()
            temp_mat.delete()
            temp_mat2.delete()
            lines.delete()

            window.requestAnimationFrame(processFrame)         
        }

        video.addEventListener('play',(event) =>{
            console.log('Webcam started playing to video element')
            window.requestAnimationFrame(processFrame)
        })

    </script>
</body>
</html>